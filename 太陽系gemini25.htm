<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互動式太陽系 3D 模型 (調整按鈕顏色)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; width: 100%; height: 100%; } /* 確保 canvas 填滿空間 */
        #infoBox {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 250px; /* 限制最大寬度 */
            display: none; /* 初始隱藏 */
            z-index: 10; /* 確保在其他元素之上 */
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap; /* 允許換行 */
            justify-content: center; /* 置中 */
            align-items: center;
            gap: 15px;
            z-index: 10;
        }


/* 使用更具體的選擇器來提高優先級 */
#controls button {
    background-color: #4a5568 !important; /* 使用 !important 確保樣式被應用 */
    color: white !important;
    padding: 8px 15px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s;
    /* 添加邊框以增強按鈕輪廓 */
    border: 1px solid #718096 !important;
}

#controls button:hover {
    background-color: #2d3748 !important; /* 懸停時使用更深的灰色 */
    border-color: #a0aec0 !important; /* 懸停時邊框變亮 */
}

/* Active 狀態不變 */
#controls button.active {
    background-color: #3182ce !important; /* 保持原有的藍色 active 狀態 */
    border-color: #4299e1 !important; /* 活動狀態邊框也變為藍色 */
}
        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none; /* 讓滑鼠事件穿透 */
            display: none; /* 初始隱藏 */
            white-space: nowrap; /* 防止文字換行 */
            z-index: 20; /* 最高層級 */
        }
        /* 軌道顏色說明樣式 */
        #legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
            max-height: calc(100vh - 40px); /* 限制最大高度 */
            overflow-y: auto; /* 超出高度時顯示滾動條 */
        }
        #legend h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: bold;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #legend ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #legend li {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            cursor: pointer; /* 添加指針提示可點擊 */
            padding: 3px 5px; /* 增加點擊區域 */
            border-radius: 4px;
            transition: background-color 0.2s;
        }
         #legend li:hover {
             background-color: rgba(255, 255, 255, 0.2); /* 懸停效果 */
         }
        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border: 1px solid #555;
            display: inline-block;
            flex-shrink: 0; /* 防止顏色塊被壓縮 */
        }
        /* 速度滑桿樣式 */
        #speedControlContainer {
            display: flex;
            align-items: center;
            color: white;
            font-size: 12px;
            margin-top: 5px; /* 與按鈕稍微間隔 */
            width: 100%; /* 讓容器佔滿控制區寬度 */
            justify-content: center; /* 置中內部元素 */
        }
        #speedSlider {
            width: 150px; /* 滑桿寬度 */
            margin: 0 10px;
            cursor: pointer;
            accent-color: #3182ce; /* 滑桿顏色 */
        }

    </style>
</head>
<body>
    <div id="infoBox">
        <h3 id="infoName" class="font-bold text-lg mb-2">行星名稱</h3>
        <p id="infoDesc">這裡是行星的相關資訊。</p>
        <button id="closeInfoBox" class="mt-3 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded text-xs">關閉</button>
    </div>

    <div id="tooltip"></div>

    <div id="controls">
        <button id="toggleOrbits">顯示/隱藏軌道</button>
        <button id="toggleRotation">暫停/啟動自轉</button>
        <button id="toggleRevolution">暫停/啟動公轉</button>
        <button id="resetViewButton">重設視角</button>
        <div id="speedControlContainer">
            <label for="speedSlider">公轉速度:</label>
            <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
            <span id="speedValue" class="ml-2">x1.0</span>
        </div>
    </div>

    <div id="legend">
        <h3>圖例 (點擊縮放/跟隨)</h3>
        <ul id="legendList">
            </ul>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 基本設定 (Basic Setup) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 光照 (Lighting) ---
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 3, 0, 0);
        scene.add(pointLight);

        // --- 控制器 (Controls) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 1000;

        // --- 行星和軌道數據 (Planet and Orbit Data) ---
        const earthSizeScale = 1;
        const planetSizes = {
            mercury: 0.383, venus: 0.949, earth: 1.0, mars: 0.532,
            jupiter: 11.21, saturn: 9.45, uranus: 4.01, neptune: 3.88, pluto: 0.186
        };
        const earthBaseSpeed = 0.01;
        const planetData = [
             { name: '水星', name_en: 'Mercury', color: 0xaaaaaa, size: planetSizes.mercury * earthSizeScale, orbitRadius: 15, baseOrbitSpeed: earthBaseSpeed * 4.15, rotationSpeed: 0.01, info: '離太陽最近的行星。實際公轉週期約0.24年。' },
             { name: '金星', name_en: 'Venus', color: 0xffe484, size: planetSizes.venus * earthSizeScale, orbitRadius: 25, baseOrbitSpeed: earthBaseSpeed * 1.63, rotationSpeed: 0.005, info: '擁有濃厚的大氣層，表面溫度極高。實際公轉週期約0.62年。' },
             { name: '地球', name_en: 'Earth', color: 0x4d91ff, size: planetSizes.earth * earthSizeScale, orbitRadius: 35, baseOrbitSpeed: earthBaseSpeed * 1.0, rotationSpeed: 0.02, info: '目前已知唯一有生命的行星。公轉週期為1年。' },
             { name: '火星', name_en: 'Mars', color: 0xff5733, size: planetSizes.mars * earthSizeScale, orbitRadius: 50, baseOrbitSpeed: earthBaseSpeed * 0.53, rotationSpeed: 0.018, info: '被稱為「紅色行星」，表面有鐵鏽。實際公轉週期約1.88年。' },
             { name: '木星', name_en: 'Jupiter', color: 0xffca8a, size: planetSizes.jupiter * earthSizeScale, orbitRadius: 80, baseOrbitSpeed: earthBaseSpeed * 0.084, rotationSpeed: 0.04, info: '太陽系中最大的行星，是氣態巨行星。實際公轉週期約11.86年。' },
             { name: '土星', name_en: 'Saturn', color: 0xf4d0a0, size: planetSizes.saturn * earthSizeScale, orbitRadius: 120, baseOrbitSpeed: earthBaseSpeed * 0.034, rotationSpeed: 0.035, info: '以其美麗的行星環而聞名。實際公轉週期約29.46年。', hasRing: true },
             { name: '天王星', name_en: 'Uranus', color: 0xafdbf5, size: planetSizes.uranus * earthSizeScale, orbitRadius: 160, baseOrbitSpeed: earthBaseSpeed * 0.012, rotationSpeed: 0.025, info: '躺著自轉的冰巨行星。實際公轉週期約84.01年。' },
             { name: '海王星', name_en: 'Neptune', color: 0x5b5dff, size: planetSizes.neptune * earthSizeScale, orbitRadius: 200, baseOrbitSpeed: earthBaseSpeed * 0.006, rotationSpeed: 0.023, info: '最遠的氣態巨行星，呈藍色。實際公轉週期約164.8年。' },
             { name: '冥王星', name_en: 'Pluto', color: 0xcccccc, size: planetSizes.pluto * earthSizeScale, orbitRadius: 240, baseOrbitSpeed: earthBaseSpeed * 0.004, rotationSpeed: 0.008, info: '一顆位於柯伊伯帶的矮行星。實際公轉週期約248年。' }
        ];

        const planets = [];
        const orbitPaths = [];
        const planetOrbitContainers = [];
        const planetMeshes = {};

        // --- 創建太陽 (Create Sun) ---
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, map: createSunTexture() });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = { name: '太陽', name_en: 'Sun', info: '太陽系的中心恆星。' };
        scene.add(sun);
        planets.push(sun);
        planetMeshes['太陽'] = sun;

        // --- 創建行星和軌道 (Create Planets and Orbits) ---
        const legendUl = document.getElementById('legendList');
        planetData.forEach(data => {
            const orbitContainer = new THREE.Object3D();
            scene.add(orbitContainer);
            planetOrbitContainers.push(orbitContainer);

            const geometry = new THREE.SphereGeometry(data.size, 32, 32);
            const material = new THREE.MeshLambertMaterial({ color: data.color });
            const planet = new THREE.Mesh(geometry, material);
            planet.position.x = data.orbitRadius;
            planet.userData = { ...data, isPlanet: true };
            planetMeshes[data.name] = planet;

            if (data.hasRing) {
                const ringGeometry = new THREE.RingGeometry(data.size * 1.2, data.size * 1.8, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide, opacity: 0.6, transparent: true });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                planet.add(ring);
            }

            orbitContainer.add(planet);
            planets.push(planet);

            const orbitGeometry = new THREE.BufferGeometry();
            const points = [];
            const segments = 128;
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(Math.cos(theta) * data.orbitRadius, 0, Math.sin(theta) * data.orbitRadius));
            }
            orbitGeometry.setFromPoints(points);
            const orbitMaterial = new THREE.LineBasicMaterial({ color: data.color, transparent: true, opacity: 0.5 });
            const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
            orbit.userData.isOrbit = true;
            scene.add(orbit);
            orbitPaths.push(orbit);

            const li = document.createElement('li');
            li.dataset.planetName = data.name;
            const colorBox = document.createElement('span');
            colorBox.className = 'color-box';
            colorBox.style.backgroundColor = `#${data.color.toString(16).padStart(6, '0')}`;
            li.appendChild(colorBox);
            li.appendChild(document.createTextNode(data.name));
            legendUl.appendChild(li);
        });

        // --- 初始相機位置 (Initial Camera Position) ---
        const initialCameraPosition = new THREE.Vector3(0, 150, 250);
        const initialTargetPosition = new THREE.Vector3(0, 0, 0);
        camera.position.copy(initialCameraPosition);
        camera.lookAt(initialTargetPosition);
        controls.target.copy(initialTargetPosition);

        // --- 狀態變數 (State Variables) ---
        let isRotationPaused = false;
        let isRevolutionPaused = false;
        let areOrbitsVisible = true;
        let simulationSpeedMultiplier = 1.0;

        // --- 相機動畫與跟隨狀態 (Camera Animation & Following State) ---
        let isAnimatingCamera = false;
        let targetCameraPosition = new THREE.Vector3();
        let targetLookAtPosition = new THREE.Vector3();
        const animationDuration = 1.0;
        let animationElapsedTime = 0;
        let startCameraPositionForAnim = new THREE.Vector3();
        let startLookAtPositionForAnim = new THREE.Vector3();
        let followingPlanet = null;
        let followOffset = new THREE.Vector3();

        // --- DOM 元素引用 (DOM Element References) ---
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue');
        const tooltip = document.getElementById('tooltip');
        const resetButton = document.getElementById('resetViewButton');

        // --- 事件監聽器 (Event Listeners) ---
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('click', onCanvasClick, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        document.getElementById('toggleOrbits').addEventListener('click', toggleOrbits);
        document.getElementById('toggleRotation').addEventListener('click', toggleRotation);
        document.getElementById('toggleRevolution').addEventListener('click', toggleRevolution);
        document.getElementById('closeInfoBox').addEventListener('click', hideInfoBox);
        speedSlider.addEventListener('input', onSpeedChange);
        legendUl.addEventListener('click', onLegendClick);
        resetButton.addEventListener('click', resetCameraView);

        // --- 滑鼠和射線投射器 (Mouse and Raycaster) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        // --- 動畫循環 (Animation Loop) ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // --- 行星動畫 (Planet Animation) ---
            planetOrbitContainers.forEach((container, index) => {
                const planet = container.children[0];
                const data = planet.userData;

                if (!isRevolutionPaused && data.isPlanet) {
                    const revolutionAmount = data.baseOrbitSpeed * simulationSpeedMultiplier * delta * 100;
                    container.rotation.y += revolutionAmount;
                }
                if (!isRotationPaused && data.isPlanet) {
                    const rotationAmount = data.rotationSpeed * delta * 50;
                    planet.rotation.y += rotationAmount;
                }
            });

            // --- 攝影機與控制器更新 (Camera and Controls Update) ---
            if (isAnimatingCamera) {
                // --- 狀態 1: 正在進行縮放/重設動畫 ---
                controls.enabled = false;
                animationElapsedTime += delta;
                const progress = Math.min(animationElapsedTime / animationDuration, 1);
                const easeProgress = 0.5 * (1 - Math.cos(Math.PI * progress));

                camera.position.lerpVectors(startCameraPositionForAnim, targetCameraPosition, easeProgress);
                controls.target.lerpVectors(startLookAtPositionForAnim, targetLookAtPosition, easeProgress);

                if (progress >= 1) {
                    isAnimatingCamera = false;
                    camera.position.copy(targetCameraPosition);
                    controls.target.copy(targetLookAtPosition);
                }
                camera.lookAt(controls.target);

            } else if (followingPlanet) {
                // --- 狀態 2: 正在跟隨行星 ---
                controls.enabled = false;
                const planetWorldPosition = new THREE.Vector3();
                followingPlanet.getWorldPosition(planetWorldPosition);

                const rotatedOffset = followOffset.clone();
                if (followingPlanet.parent && followingPlanet.parent.isObject3D) {
                    rotatedOffset.applyQuaternion(followingPlanet.parent.quaternion);
                }

                const targetCamPos = planetWorldPosition.clone().add(rotatedOffset);

                camera.position.lerp(targetCamPos, 0.1);
                controls.target.copy(planetWorldPosition);
                camera.lookAt(controls.target);

            } else {
                // --- 狀態 3: 自由控制 ---
                controls.enabled = true;
                controls.update();
            }

            // 渲染場景
            renderer.render(scene, camera);
        }

        // --- 工具函數 (Utility Functions) ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onCanvasClick(event) {
            if (isAnimatingCamera) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets, true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                const targetObject = clickedObject.parent?.userData?.isPlanet ? clickedObject.parent : clickedObject;

                if (targetObject.userData.name) {
                    if (targetObject !== followingPlanet) {
                        if (planetMeshes[targetObject.userData.name] && targetObject.userData.isPlanet) {
                            zoomToPlanet(planetMeshes[targetObject.userData.name]);
                        } else {
                            showInfoBox(targetObject.userData);
                            followingPlanet = null; // 如果點擊的是太陽或其他非跟隨物體，取消跟隨
                        }
                    } else {
                         // 如果點擊的是正在跟隨的行星，顯示資訊
                        showInfoBox(targetObject.userData);
                    }
                }
            } else {
                // 點擊空白處
                 hideInfoBox();
                 if (followingPlanet) {
                    // 如果之前在跟隨，可以選擇取消跟隨或保持跟隨
                    // 目前行為：保持跟隨，僅隱藏信息框
                    // 若要取消跟隨： followingPlanet = null;
                 }
            }
        }


        function onMouseMove(event) {
             mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
             mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
             raycaster.setFromCamera(mouse, camera);
             const intersects = raycaster.intersectObjects(planets, true); // `true` for recursive check

             if (intersects.length > 0) {
                 const firstIntersect = intersects[0].object;
                  // 檢查父對象是否為行星，處理點擊到行星環的情況
                 const targetObject = firstIntersect.parent?.userData?.isPlanet ? firstIntersect.parent : firstIntersect;

                 if (targetObject !== intersectedObject && targetObject.userData.name) { // 確保對象有名字
                     intersectedObject = targetObject;
                     tooltip.textContent = intersectedObject.userData.name;
                     tooltip.style.left = `${event.clientX + 10}px`;
                     tooltip.style.top = `${event.clientY + 10}px`;
                     tooltip.style.display = 'block';
                 } else if (targetObject === intersectedObject) {
                     // 如果滑鼠仍在同一個物體上，只需更新位置
                     tooltip.style.left = `${event.clientX + 10}px`;
                     tooltip.style.top = `${event.clientY + 10}px`;
                 }
             } else {
                 if (intersectedObject) {
                     // 滑鼠移出任何可交互物體
                     tooltip.style.display = 'none';
                 }
                 intersectedObject = null;
             }
        }

        function showInfoBox(data) {
            document.getElementById('infoName').textContent = data.name;
            document.getElementById('infoDesc').textContent = data.info || `關於 ${data.name} 的資訊。`;
            document.getElementById('infoBox').style.display = 'block';
        }

        function hideInfoBox() {
            document.getElementById('infoBox').style.display = 'none';
        }

        function toggleOrbits() {
            areOrbitsVisible = !areOrbitsVisible;
            orbitPaths.forEach(orbit => { orbit.visible = areOrbitsVisible; });
            document.getElementById('toggleOrbits').classList.toggle('active', areOrbitsVisible);
        }

        function toggleRotation() {
            isRotationPaused = !isRotationPaused;
            document.getElementById('toggleRotation').classList.toggle('active', !isRotationPaused);
        }

        function toggleRevolution() {
            isRevolutionPaused = !isRevolutionPaused;
            document.getElementById('toggleRevolution').classList.toggle('active', !isRevolutionPaused);
        }

        function onSpeedChange(event) {
            simulationSpeedMultiplier = parseFloat(event.target.value);
            speedValueSpan.textContent = `x${simulationSpeedMultiplier.toFixed(1)}`;
        }

        function onLegendClick(event) {
            const listItem = event.target.closest('li');
            if (listItem && listItem.dataset.planetName) {
                const planetName = listItem.dataset.planetName;
                const targetPlanet = planetMeshes[planetName];
                 if (targetPlanet && targetPlanet !== followingPlanet) { // 確保不是點擊當前跟隨的行星
                    zoomToPlanet(targetPlanet);
                } else if (targetPlanet === followingPlanet) {
                     // 如果點擊的是正在跟隨的行星，只顯示資訊框
                     showInfoBox(targetPlanet.userData);
                }
            }
        }

        function zoomToPlanet(planetMesh) {
            const planetWorldPosition = new THREE.Vector3();
            planetMesh.getWorldPosition(planetWorldPosition);

            const planetRadius = planetMesh.geometry.parameters.radius || 1;
            // 計算偏移距離，確保較大的行星也能完整顯示
            const offsetDistance = planetRadius * 6; // 基礎距離為半徑的6倍
            const baseOffset = new THREE.Vector3(0, planetRadius * 1.5, offsetDistance); // 稍微抬高視角

            // 初始偏移量需要考慮行星當前在軌道上的位置（其父容器的旋轉）
            const initialRotatedOffset = baseOffset.clone();
             if (planetMesh.parent && planetMesh.parent.isObject3D) { // 行星應該有父容器（軌道容器）
                 initialRotatedOffset.applyQuaternion(planetMesh.parent.quaternion);
             }

            targetCameraPosition.copy(planetWorldPosition).add(initialRotatedOffset);
            targetLookAtPosition.copy(planetWorldPosition);

            // 保存用於持續跟隨的基礎偏移量（相對於行星本身）
            followOffset.copy(baseOffset);
            followingPlanet = planetMesh; // 設定正在跟隨的行星
            startCameraAnimation(); // 開始動畫
        }


        function resetCameraView() {
            followingPlanet = null; // 取消跟隨
            targetCameraPosition.copy(initialCameraPosition); // 目標設為初始位置
            targetLookAtPosition.copy(initialTargetPosition); // 目標設為初始焦點
            startCameraAnimation(); // 開始動畫
        }

        function startCameraAnimation() {
            startCameraPositionForAnim.copy(camera.position); // 記錄當前相機位置
            startLookAtPositionForAnim.copy(controls.target); // 記錄當前視角目標

            isAnimatingCamera = true;
            animationElapsedTime = 0;
            hideInfoBox(); // 開始動畫時隱藏信息框
        }


        function createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            // Create a radial gradient for the sun's glow
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 180, 1)'); // Center (bright yellow)
            gradient.addColorStop(0.6, 'rgba(255, 200, 0, 1)'); // Middle (orange-yellow)
            gradient.addColorStop(1, 'rgba(255, 150, 0, 0.8)'); // Edge (orange, slightly transparent)
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            // Add some subtle noise/texture (optional)
            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 20; i++) { context.beginPath(); context.arc(Math.random() * 64, Math.random() * 64, Math.random() * 1.5, 0, 2 * Math.PI); context.fill(); }
             context.fillStyle = 'rgba(200, 100, 0, 0.4)';
            for (let i = 0; i < 15; i++) { context.beginPath(); context.arc(Math.random() * 64, Math.random() * 64, Math.random() * 2, 0, 2 * Math.PI); context.fill(); }
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 初始化按鈕狀態和速度顯示 (Initialize Button States and Speed Display) ---
        document.getElementById('toggleOrbits').classList.toggle('active', areOrbitsVisible);
        document.getElementById('toggleRotation').classList.toggle('active', !isRotationPaused);
        document.getElementById('toggleRevolution').classList.toggle('active', !isRevolutionPaused);
        speedValueSpan.textContent = `x${parseFloat(speedSlider.value).toFixed(1)}`;
        simulationSpeedMultiplier = parseFloat(speedSlider.value);

        // --- 啟動動畫 (Start Animation) ---
        window.onload = function() {
             try {
                 animate();
             } catch(error) {
                 console.error("動畫啟動時發生錯誤 (Error starting animation):", error);
                 // 提供用戶友好的錯誤信息
                 document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: sans-serif;">啟動 3D 動畫時發生錯誤。請檢查瀏覽器控制台以獲取詳細資訊。<br>An error occurred while starting the 3D animation. Please check the browser console for details.</div>`;
             }
        }

    </script>
</body>
</html>
