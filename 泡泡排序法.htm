<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泡泡排序法互動教學 (左右對照)</title>
    <style>
        /* 基本樣式 */
        body {
            font-family: 'Microsoft JhengHei', '微軟正黑體', sans-serif;
            padding: 15px;
            background-color: #f9f9f9;
            margin: 0;
        }

        /* 主容器 - Flex佈局 */
        .main-container {
            display: flex;
            flex-wrap: wrap; /* 允許換行 */
            gap: 20px; /* 欄間距 */
            align-items: flex-start; /* 頂部對齊 */
        }

        /* 左欄和右欄 */
        .left-column, .right-column {
            flex: 1; /* 均分寬度 */
            min-width: 320px; /* 最小寬度，防止過窄 */
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.05);
        }

        /* Canvas 樣式 */
        canvas {
            border: 1px solid #ccc;
            background-color: #ffffff;
            margin-bottom: 15px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            display: block; /* 避免底部多餘空間 */
            max-width: 100%; /* 響應式寬度 */
            height: auto; /* 保持長寬比 */
        }

        /* 控制區、資訊區 */
        .controls, .info {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            text-align: center;
        }

        /* 程式碼區 */
        .code-section {
             /* 不再需要獨立背景和陰影，因為父元素 right-column 有 */
        }

        /* 標題樣式 */
        h1 {
             width: 100%; /* 讓 H1 跨越兩欄 */
             text-align: center;
             margin-bottom: 20px;
             color: #333;
             font-size: 1.8em;
        }
        h2 {
            color: #333;
            margin-top: 0; /* 移除右欄標題的上邊距 */
            text-align: center;
        }

        /* 按鈕樣式 */
        button {
            padding: 8px 15px;
            margin: 5px;
            font-size: 15px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* 輸入框樣式 */
        input[type="text"] {
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-width: 150px;
        }

        /* 狀態文字樣式 */
        #status {
            margin-top: 10px;
            font-weight: bold;
            min-height: 20px;
            color: #555;
            font-size: 1.1em;
        }

        /* 解釋文字樣式 */
        #explanation {
            margin-top: 10px;
            color: #444;
            text-align: left;
            line-height: 1.6;
        }

        /* 程式碼容器樣式 */
        .code-container {
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
            white-space: pre; /* 保留空格和換行 */
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto; /* 水平滾動條 */
            font-size: 0.95em;
            line-height: 1.4;
            max-height: 500px; /* 限制最大高度並滾動 */
            overflow-y: auto;
        }

        /* 程式碼高亮樣式 */
        .highlight-code {
            background-color: #fff3cd;
            font-weight: bold;
            padding: 0.1em 0.2em;
            border-radius: 3px;
            outline: 1px solid #f0e68c; /* 加個細框更明顯 */
        }

        /* 響應式設計 - 小螢幕時堆疊 */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column; /* 垂直堆疊 */
            }
            .left-column, .right-column {
                width: 100%; /* 佔滿寬度 */
                margin-bottom: 15px; /* 增加堆疊時的間距 */
            }
            h1 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>

    <h1>泡泡排序法 (Bubble Sort) 互動教學</h1>

    <div class="main-container">

        <!-- 左欄：視覺化、控制、說明 -->
        <div class="left-column">
            <canvas id="sortCanvas" width="500" height="250"></canvas> 

            <div class="controls">
                <label for="dataInput">輸入數字 (逗號分隔): </label>
                <input type="text" id="dataInput" value="5,1,4,2,8" aria-label="輸入要排序的數字，用逗號分隔">
                <button id="resetBtn">重設/載入</button>
                <button id="nextStepBtn">下一步</button>
                <button id="autoPlayBtn">自動播放</button>
            </div>

            <div class="info">
                <div id="status" aria-live="polite">請點擊 "重設/載入" 開始</div>
                <div id="explanation"></div>
            </div>
        </div>

        <!-- 右欄：程式碼 -->
        <div class="right-column">
            <div class="code-section">
                <h2>對應 C 語言程式碼</h2>
                {/* --- 完全依照使用者提供的 C 程式碼 --- */}
                <div class="code-container" id="cCode" aria-label="C 語言泡泡排序法程式碼範例">#include <stdio.h>

int main() {
    int num[5];
    int i, j, temp;

    // 使用者輸入5個數字
    <span id="code-input-loop">for (i = 0; i < 5; i++) {</span>
        scanf("%d", &num[i]);
    }

    // 泡泡排序法
    <span id="code-outer-loop">for (i = 0; i < 4; i++) {</span>
        <span id="code-inner-loop">for (j = 0; j < 4 - i; j++) {</span>
            <span id="code-compare">if (num[j] > num[j + 1]) {</span>
                <span id="code-swap">temp = num[j];
                num[j] = num[j + 1];
                num[j + 1] = temp;</span>
            }
        }
    }

    // 輸出排序後的結果
    <span id="code-output-loop">for (i = 0; i < 5; i++) {</span>
        printf("%d ", num[i]);
    }
    printf("\n");

    return 0;
}</div>
            </div>
        </div>

    </div> {/* <!-- main-container 結束 --> */}

    <script>
        // --- DOM 元素獲取 ---
        const canvas = document.getElementById('sortCanvas');
        const ctx = canvas.getContext('2d');
        const dataInput = document.getElementById('dataInput');
        const resetBtn = document.getElementById('resetBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const autoPlayBtn = document.getElementById('autoPlayBtn');
        const statusDiv = document.getElementById('status');
        const explanationDiv = document.getElementById('explanation');
        const cCodeDiv = document.getElementById('cCode');

        // --- 狀態變數 ---
        let array = [];
        let arrayStates = [];
        let currentStateIndex = -1;
        let autoPlayInterval = null;
        let autoPlaySpeed = 800;

        // --- Canvas 繪圖常數與函數 ---
        const barPadding = 8; // 間距可以小一點
        const topMargin = 30;
        const bottomMargin = 20;

        function drawArray(arr, comparingIndices = [], swappedIndices = [], sortedIndices = []) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (!arr || arr.length === 0) return;

            const n = arr.length;
            const totalPadding = barPadding * (n + 1);
            const availableWidth = canvasWidth - totalPadding;
            const barWidth = Math.max(5, availableWidth / n);
            const maxVal = arr.length > 0 ? Math.max(...arr, 1) : 1;
            const availableHeight = canvasHeight - topMargin - bottomMargin;

            arr.forEach((value, index) => {
                const barHeight = Math.max(1, (value / maxVal) * availableHeight);
                const x = barPadding + index * (barWidth + barPadding);
                const y = canvasHeight - bottomMargin - barHeight;

                if (comparingIndices.includes(index)) {
                    ctx.fillStyle = '#ffcc66'; // 比較中
                } else if (swappedIndices.includes(index)) {
                    ctx.fillStyle = '#ff6666'; // 交換中
                } else if (sortedIndices.includes(index)) {
                    ctx.fillStyle = '#99cc99'; // 已排序
                } else {
                    ctx.fillStyle = '#66b3ff'; // 預設
                }
                ctx.fillRect(x, y, barWidth, barHeight);

                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                const fontSize = Math.max(8, Math.min(14, barWidth * 0.35)); // 字體可稍小
                ctx.font = `${fontSize}px Arial`;
                const textY = Math.max(12, y - 5);
                ctx.fillText(value, x + barWidth / 2, textY);
            });
        }

        // --- 泡泡排序狀態生成 (對應無優化 C Code) ---
        function generateBubbleSortStates(initialArray) {
            arrayStates = [];
            let arr = [...initialArray];
            const n = arr.length;
            if (n === 0) return;

            let i, j, temp;
            let message = "";
            let highlightCodeIds = [];

            // 初始狀態 (代表輸入完成)
            arrayStates.push({
                arraySnapshot: [...arr], i: -1, j: -1,
                comparingIndices: [], swappedIndices: [], sortedIndices: [],
                message: "資料載入完成，準備開始排序。",
                highlightCodeIds: ['code-input-loop'] // 高亮輸入迴圈
            });

            // 排序迴圈
            for (i = 0; i < n - 1; i++) {
                message = `第 ${i + 1} 輪開始 (i=${i})。`;
                highlightCodeIds = ['code-outer-loop'];
                arrayStates.push({
                    arraySnapshot: [...arr], i: i, j: -1,
                    comparingIndices: [], swappedIndices: [],
                    sortedIndices: buildSortedIndices(n, i),
                    message: message, highlightCodeIds: highlightCodeIds
                });

                for (j = 0; j < n - 1 - i; j++) {
                    message = `比較索引 ${j} (值 ${arr[j]}) 和索引 ${j + 1} (值 ${arr[j + 1]})。`;
                    highlightCodeIds = ['code-inner-loop', 'code-compare']; // 高亮內迴圈和比較
                    arrayStates.push({
                        arraySnapshot: [...arr], i: i, j: j,
                        comparingIndices: [j, j + 1], swappedIndices: [],
                        sortedIndices: buildSortedIndices(n, i),
                        message: message, highlightCodeIds: highlightCodeIds
                    });

                    if (arr[j] > arr[j + 1]) {
                        message = `因為 ${arr[j]} > ${arr[j + 1]}，執行交換。`;
                        highlightCodeIds = ['code-swap']; // 高亮交換區塊
                        // 交換前標示
                        arrayStates.push({
                            arraySnapshot: [...arr], i: i, j: j,
                            comparingIndices: [], swappedIndices: [j, j + 1],
                            sortedIndices: buildSortedIndices(n, i),
                            message: message, highlightCodeIds: highlightCodeIds
                        });

                        // 執行交換
                        temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;

                        // 交換後狀態
                        message = `交換完成：索引 ${j} 為 ${arr[j]}, 索引 ${j + 1} 為 ${arr[j + 1]}。`;
                        arrayStates.push({
                            arraySnapshot: [...arr], i: i, j: j,
                            comparingIndices: [], swappedIndices: [j, j + 1], // 交換完可以還顯示紅色一下
                            sortedIndices: buildSortedIndices(n, i),
                            message: message, highlightCodeIds: [] // 交換完成後不高亮特定行
                        });
                    } else {
                        message = `因為 ${arr[j]} <= ${arr[j + 1]}，不需交換。`;
                        highlightCodeIds = ['code-compare']; // 停留在比較行
                         arrayStates.push({
                            arraySnapshot: [...arr], i: i, j: j,
                            comparingIndices: [j, j + 1], // 保持比較黃色
                            swappedIndices: [],
                            sortedIndices: buildSortedIndices(n, i),
                            message: message, highlightCodeIds: highlightCodeIds
                        });
                    }
                } // 內迴圈結束

                // 輪結束，標記排序好的元素
                message = `第 ${i + 1} 輪結束，元素 ${arr[n - 1 - i]} 已就位。`;
                highlightCodeIds = ['code-outer-loop']; // 指回外迴圈
                arrayStates.push({
                    arraySnapshot: [...arr], i: i, j: j - 1, // j 為內迴圈最後值
                    comparingIndices: [], swappedIndices: [],
                    sortedIndices: buildSortedIndices(n, i + 1),
                    message: message, highlightCodeIds: highlightCodeIds
                });
            } // 外迴圈結束

            // 最終完成狀態
            message = "排序完成。";
            highlightCodeIds = ['code-output-loop']; // 高亮輸出迴圈
            arrayStates.push({
                 arraySnapshot: [...arr], i: n - 1, j: -1,
                 comparingIndices: [], swappedIndices: [],
                 sortedIndices: buildSortedIndices(n, n),
                 message: message, highlightCodeIds: highlightCodeIds
            });
        }

        function buildSortedIndices(totalLength, numberOfSorted) {
            const indices = [];
            for (let k = 0; k < numberOfSorted; k++) {
                indices.push(totalLength - 1 - k);
            }
            return indices;
        }

        // --- 更新 UI 顯示 ---
        function displayState(stateIndex) {
            if (stateIndex < 0 || stateIndex >= arrayStates.length) return;

            const { arraySnapshot, i, j, comparingIndices, swappedIndices, sortedIndices, message, highlightCodeIds } = arrayStates[stateIndex];

            drawArray(arraySnapshot, comparingIndices, swappedIndices, sortedIndices);
            statusDiv.textContent = message;
            updateCodeHighlight(highlightCodeIds);
            updateExplanation(stateIndex);

            nextStepBtn.disabled = (stateIndex === arrayStates.length - 1);
            autoPlayBtn.disabled = (stateIndex === arrayStates.length - 1);
            if (stateIndex === arrayStates.length - 1) {
                stopAutoPlay();
                autoPlayBtn.textContent = "播放完畢";
            }
        }

        function updateCodeHighlight(highlightCodeIds) {
            // 先移除所有高亮
            const spans = cCodeDiv.querySelectorAll('span[id^="code-"]');
            spans.forEach(span => span.classList.remove('highlight-code'));
            // 再添加當前需要的高亮
            highlightCodeIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('highlight-code');
                    // 滾動到高亮行 (如果需要)
                    // element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });
        }

        function updateExplanation(stateIndex) {
            if (stateIndex < 0 || stateIndex >= arrayStates.length) return;

            const { arraySnapshot, i, j, comparingIndices, swappedIndices, message } = arrayStates[stateIndex];
            const n = arraySnapshot.length;
            let explanation = "";

             if (message.includes("資料載入")) {
                 explanation = `初始化數列。對應 C 程式碼中的 <code class="highlight-code">for</code> 迴圈和 <code class="highlight-code">scanf</code> 輸入。`;
             } else if (message.includes("輪開始")) {
                 explanation = `進入外層迴圈，開始第 ${i + 1} 輪 (i=${i})。此輪將比較 ${n - 1 - i} 次，將未排序部分的最大值移到最右邊。對應 <code class="highlight-code">for (i = ...)</code>。`;
             } else if (comparingIndices.length > 0 && message.includes("比較索引")) {
                 explanation = `進入內層迴圈 (j=${j})，比較相鄰元素：索引 ${j} (值 ${arraySnapshot[j]}) 和索引 ${j + 1} (值 ${arraySnapshot[j+1]})。對應 <code class="highlight-code">for (j = ...)</code> 及 <code class="highlight-code">if (...)</code> 判斷。`;
             } else if (swappedIndices.length > 0 && message.includes("執行交換")) {
                  let val1 = "?", val2 = "?";
                  if(stateIndex > 0) { // 從前一狀態取值較準確
                       const prevState = arrayStates[stateIndex-1];
                       if(prevState.comparingIndices.length > 0 && prevState.comparingIndices[0] === swappedIndices[0]){
                            val1 = prevState.arraySnapshot[swappedIndices[0]];
                            val2 = prevState.arraySnapshot[swappedIndices[1]];
                       } else { // 備用方案
                            val1 = arraySnapshot[swappedIndices[0]];
                            val2 = arraySnapshot[swappedIndices[1]];
                       }
                  }
                  explanation = `因為 ${val1} > ${val2}，條件成立，執行交換。對應 <code class="highlight-code">if</code> 內的交換程式碼 (<code class="highlight-code">temp = ...</code>)。`;
             } else if (swappedIndices.length > 0 && message.includes("交換完成")) {
                 explanation = `交換完畢。索引 ${j} 現在是 ${arraySnapshot[j]}，索引 ${j + 1} 是 ${arraySnapshot[j+1]}。繼續內層迴圈下一次比較。`;
             } else if (comparingIndices.length > 0 && message.includes("不需交換")) {
                 explanation = `因為 ${arraySnapshot[j]} <= ${arraySnapshot[j+1]}，條件不成立，跳過交換步驟。繼續內層迴圈下一次比較。`;
             } else if (message.includes("輪結束")) {
                 explanation = `第 ${i + 1} 輪內層迴圈執行完畢。元素 ${arraySnapshot[n - 1 - i]} 已確定在最終位置 (標為綠色)。準備進入下一輪 (如果 i < ${n-2})。`;
             } else if (message.includes("排序完成")) {
                 explanation = `所有 ${n-1} 輪排序執行完畢。數列已排序完成！對應 C 程式碼最後的 <code class="highlight-code">printf</code> 輸出迴圈。`;
             }

            explanationDiv.innerHTML = explanation;
        }


        // --- 事件處理函數 ---
        function handleReset() {
            stopAutoPlay();
            const inputText = dataInput.value.trim();
            const potentialArray = inputText.split(',')
                                        .map(s => s.trim())
                                        .filter(s => s !== '')
                                        .map(Number)
                                        .filter(n => !isNaN(n) && isFinite(n));

            if (potentialArray.length === 0) {
                alert("請輸入有效的數字序列，用逗號分隔！例如：5,1,4,2,8");
                array = [];
                drawArray([]);
                statusDiv.textContent = "請輸入有效數字。";
                explanationDiv.innerHTML = "";
                updateCodeHighlight([]);
                currentStateIndex = -1;
                nextStepBtn.disabled = true;
                autoPlayBtn.disabled = true;
                autoPlayBtn.textContent = "自動播放";
                return;
            }
             if (potentialArray.length !== 5) {
                  // alert("提示：建議輸入 5 個數字以完全對應右側 C 程式碼。");
                  // 即使提示，仍允許處理
             }
             if (potentialArray.length > 20) { // 減少建議的數量，因為寬度有限
                 alert("提示：輸入數字過多可能影響視覺效果。");
             }


            array = potentialArray;
            generateBubbleSortStates(array);
            currentStateIndex = 0;
            displayState(currentStateIndex);
            autoPlayBtn.textContent = "自動播放"; // 重設按鈕文字
        }

        function handleNextStep() {
            if (currentStateIndex < arrayStates.length - 1) {
                currentStateIndex++;
                displayState(currentStateIndex);
            }
            stopAutoPlay(); // 手動下一步時停止自動播放
        }

        function autoPlayStep() {
            if (currentStateIndex < arrayStates.length - 1) {
                currentStateIndex++;
                displayState(currentStateIndex);
            } else {
                stopAutoPlay();
            }
        }

        function startAutoPlay() {
            if (!autoPlayInterval && currentStateIndex < arrayStates.length - 1) {
                 autoPlayBtn.textContent = "暫停";
                 nextStepBtn.disabled = true;
                 autoPlayStep(); // 先走一步
                 if (currentStateIndex < arrayStates.length - 1){ // 避免已是最後一步
                     autoPlayInterval = setInterval(autoPlayStep, autoPlaySpeed);
                 } else {
                     stopAutoPlay(); // 如果第一步就是最後一步
                 }
            }
        }

        function stopAutoPlay() {
             if (autoPlayInterval) {
                 clearInterval(autoPlayInterval);
                 autoPlayInterval = null;
             }
             // 更新按鈕狀態，除非已經結束
             if (currentStateIndex < arrayStates.length - 1) {
                autoPlayBtn.textContent = "自動播放";
                nextStepBtn.disabled = false;
             } else {
                 autoPlayBtn.textContent = "播放完畢";
                 autoPlayBtn.disabled = true; // 結束了就禁用
                 nextStepBtn.disabled = true;
             }
        }

        function handleAutoPlayToggle() {
             if (currentStateIndex === -1 || currentStateIndex >= arrayStates.length - 1) {
                 return; // 未開始或已結束
             }
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        // --- 初始化 ---
        function init() {
            resetBtn.addEventListener('click', handleReset);
            nextStepBtn.addEventListener('click', handleNextStep);
            autoPlayBtn.addEventListener('click', handleAutoPlayToggle);

            // 初始提示
            explanationDiv.innerHTML = "這是一個泡泡排序法的互動演示。<br>左側是數值的視覺化表示，右側是對應的 C 語言程式碼。<br>請使用上方的控制項逐步執行或自動播放排序過程，觀察數值變化與程式碼執行的對應關係。";
            updateCodeHighlight([]);
            nextStepBtn.disabled = true;
            autoPlayBtn.disabled = true;

            // 頁面載入時自動用預設值執行一次重設
            handleReset();
        }

        window.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>